> 作用域分两种，第一种叫普遍 -> ==词法作用域==，第二种是动态作用域。

## 词法阶段

**词法化**，大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。

**词法作用域**

> 作用域查找会在找到第一个匹配的标识符时停止
>
> 全局变量会自动成为全局对象(比如浏览器中的 `window` 对象)的属性
>
> 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。

- `eval`

```js
function foo(str, a) {
  eval(str) // 欺骗!
  console.log(a, b)
}
var b = 2
foo('var b = 3;', 1) // 1, 3
```

在严格模式的程序中，`eval(..) `在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。

```js
function foo(str) {
  'use strict'
  eval(str)
  console.log(a) // // ReferenceError: a is not defined
}

foo('var a = 2')
```

`setTimeout(..)`和 `setInterval(..) `的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的 函数代码。这些功能已经过时且并不被提倡。不要使用它们!

`new Function(..)` 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转 化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 `eval(..) `略微安全一些，但也要尽量避免使用。

- `with` **（现在都不用了）**

`with` 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用==对象本身==。

```js
function foo(obj) {
  with (obj) {
    a = 2
  }
}
var o1 = {
  a: 3,
}
var o2 = {
  b: 3,
}
foo(o1)
console.log(o1.a) // 2
foo(o2)
console.log(o2.a) // undefined
console.log(a) // 2——不好，a 被泄漏到全局作用域上了!
```

`with` 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

可以这样理解，当我们传递 `o1` 给 `with` 时，`with` 所声明的作用域是 `o1`，而这个作用域中含 有一个同 `o1.a `属性相符的标识符。但当我们将 `o2` 作为作用域时，其中并没有 `a` 标识符， 因此进行了正常的 `LHS` 标识符查找(查看第 1 章)。

`o2` 的作用域、`foo(..) `的作用域和全局作用域中都没有找到标识符 `a`，因此当 `a=2` 执行 时，自动创建了一个全局变量(因为是非严格模式)。

## 性能

如果引擎在代码中发现了`eval(..)`或 `with`，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 `eval(..)` 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 `with` 用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了 `eval(..) `或 `with`，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

如果代码中大量使用 `eval(..) `或 `with`，那么运行起来一定会变得非常慢。无论引擎多聪 明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。
