// JavaScript 允许我们像使用对象一样使用原始类型（字符串，数字等）。JavaScript 还提供了这样的调用方法。但是,原始类型到底也不是对象,来看看这里这两者之间的关键区别
/* 
原始值:
- 原始类型的 一种值
- 有7种原始类型: string boolean number bigint null undefined symbol

对象:
- 能够存储 多个值 东作为属性
- 可以使用大括号 {} 创建对象,而且还有其他种类的对象,例如函数就是对象
*/

// 关于对象的最好的事儿之一是，我们可以把一个函数作为对象的属性存储到对象中。
let john = {
  name: 'John',
  sayHi: function () {
    console.log('Hi buddy!')
  },
}
john.sayHi()
// 对象比原始类型“更重”。它们需要额外的资源来支持运作。

// 当作对象的原始类型
/*
javascript 创建者会面临一个悖论:
1. 人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好使用方法来访问它们。
2. 原始类型必须尽可能的简单轻量。

解决办法看起来多少有点尴尬:
1. 原始类型仍然是原始的。与预期相同，提供单个值
2. JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。
3. 为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。
*/

// 例如，字符串方法 str.toUpperCase() 返回一个大写化处理的字符串。
let str = 'Hello'
console.log(str.toUpperCase())

// 实际发生的情况:
/*
1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有可用的方法，例如 toUpperCase()。
2. 该方法运行并返回一个新的字符串（由 alert 显示）。
3. 特殊对象被销毁，只留下原始值 str。
*/

// 像 Java 这样的语言允许我们使用 new Number(1) 这种语法,明确为原始类型创建"对象包装器".然而在 JavaScript 种,由于历史原因这样也是可以的,但是很不推荐,这样做会有问题:
console.log(typeof 0)
console.log(typeof new Number(0))

// 另一方面，调用不带 new（关键字）的 String/Number/Boolean 函数是可以的且有效的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。
let num = Number('123')
console.log(typeof num)

// null 和 undefined 没有任何方法

// 任务

/*
我能为字符串添加一个属性吗？
重要程度: 5
思考下面的代码：

let str = "Hello";

str.test = 5;

console.log(str.test);
你怎么想的呢，它会工作吗？会得到什么样的结果？
*/

// 先来运行一下:

str = 'Hello'
str.test = 5 // (*)
console.log(str.test)
/*
根据你是否开启了严格模式 use strict，会得到如下结果：

1. undefined（非严格模式）
2. 报错（严格模式）。

为什么？让我们看看在 (*) 那一行到底发生了什么：

1. 当访问 str 的属性时，一个“对象包装器”被创建了。
2. 在严格模式下，向其写入内容会报错。
3. 否则，将继续执行带有属性的操作，该对象将获得 test 属性，但是此后，“对象包装器”将消失，因此在最后一行，str 并没有该属性的踪迹。

这个例子清楚地表明，原始类型不是对象。

它们不能存储额外的数据。
*/
